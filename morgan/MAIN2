{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "    Odor Properties\n",
      "0          absolute\n",
      "1           acetate\n",
      "2            acetic\n",
      "3           acetone\n",
      "4      acetophenone\n",
      "..              ...\n",
      "512            wine\n",
      "513     wintergreen\n",
      "514            wood\n",
      "515           yeast\n",
      "516          yogurt\n",
      "\n",
      "[517 rows x 1 columns]\n",
      "    Odor Property  Occurrence\n",
      "0        absolute           3\n",
      "1         acetate           3\n",
      "2          acetic           3\n",
      "3         acetone           5\n",
      "4    acetophenone           2\n",
      "..            ...         ...\n",
      "512          wine          62\n",
      "513   wintergreen           7\n",
      "514          wood         286\n",
      "515         yeast           5\n",
      "516        yogurt           1\n",
      "\n",
      "[517 rows x 2 columns]\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import itertools\n",
    "from gensim.models.poincare import PoincareModel\n",
    "\n",
    "# Read the CSV file\n",
    "data = pd.read_csv('/home/ritesh/Desktop/MOLECULES/morgan/data.csv')\n",
    "\n",
    "# Create an empty dictionary to store unique properties and their corresponding SMILES notations\n",
    "odor = {}\n",
    "\n",
    "# Iterate over each row in dataframe\n",
    "for index, row in data.iterrows():\n",
    "    smiles = row['SMILES']\n",
    "    prop_list = [prop.strip() for prop in str(row['ODOR']).split(',')]\n",
    "\n",
    "    # Check if SMILES notation is already present in odor dictionary,\n",
    "    # If not, add it as a new key with initial value of empty set {}\n",
    "    if smiles not in odor:\n",
    "        odor[smiles] = set()\n",
    "\n",
    "        # Add each property to corresponding SMILES notation set\n",
    "    for prop in prop_list:\n",
    "        if prop != '':\n",
    "            odor[smiles].add(prop)\n",
    "\n",
    "# Get all unique property values\n",
    "all_properties = sorted(set(prop for props in odor.values() for prop in props))\n",
    "\n",
    "# Create an empty DataFrame with columns as unique property values and rows as unique SMILES notations\n",
    "property_df = pd.DataFrame(0, index=odor.keys(), columns=all_properties)\n",
    "\n",
    "# Set 1 or 0 based on presence or absence of each property for respective SMILES notation\n",
    "for smiles, props_set in odor.items():\n",
    "    property_df.loc[smiles, list(props_set)] += 1\n",
    "\n",
    "\n",
    "def generate_edge(x, colName):\n",
    "    temp = list(colName[(x > 0).values])\n",
    "\n",
    "    if len(temp) > 1:\n",
    "        edges = list(itertools.permutations(temp, r=2))\n",
    "    else:\n",
    "        edges = []\n",
    "\n",
    "    return edges\n",
    "\n",
    "\n",
    "colName = property_df.columns\n",
    "non_zero_cols = property_df.apply(lambda x: generate_edge(x, colName), axis=1)\n",
    "\n",
    "relations_list = []\n",
    "for index, val in non_zero_cols.items():\n",
    "    relations_list.extend(val)\n",
    "\n",
    "# Create a DataFrame containing all unique odor properties\n",
    "df_aroma = pd.DataFrame(all_properties, columns=['Odor Properties'])\n",
    "\n",
    "# Print the occurrence of each odor property in the DataFrame\n",
    "odor_occurrence = property_df.sum().reset_index()\n",
    "odor_occurrence.columns = ['Odor Property', 'Occurrence']\n",
    "\n",
    "print(df_aroma)\n",
    "print(odor_occurrence)\n",
    "\n",
    "# Poincare Embedding using gensim library\n",
    "dim = 20\n",
    "model = PoincareModel(train_data=relations_list, size=dim,\n",
    "                      burn_in=10)  # train a n-dimensional embedding with 10 burn-in epochs\n",
    "\n",
    "epochs_to_train = 10\n",
    "total_examples_trained_per_epoch = len(relations_list)\n",
    "total_examples_trained_so_far = 0\n",
    "\n",
    "for epoch in range(epochs_to_train):\n",
    "    model.train(total_examples_trained_per_epoch, print_every=50000)\n",
    "    total_examples_trained_so_far += total_examples_trained_per_epoch\n",
    "\n",
    "    progress_percent = (total_examples_trained_so_far / (epochs_to_train * total_examples_trained_per_epoch)) * 100\n",
    "    print(f\"Training Progress: {progress_percent}%\")\n",
    "\n",
    "model.save(\"poincare_model.pkl\")\n",
    "loaded_model = PoincareModel.load('poincare_model.pkl')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "'SMILES'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "File \u001b[0;32m~/anaconda3/envs/MOLECULES/lib/python3.11/site-packages/pandas/core/indexes/base.py:3653\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   3652\u001b[0m \u001b[39mtry\u001b[39;00m:\n\u001b[0;32m-> 3653\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49m_engine\u001b[39m.\u001b[39;49mget_loc(casted_key)\n\u001b[1;32m   3654\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mKeyError\u001b[39;00m \u001b[39mas\u001b[39;00m err:\n",
      "File \u001b[0;32m~/anaconda3/envs/MOLECULES/lib/python3.11/site-packages/pandas/_libs/index.pyx:147\u001b[0m, in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[0;34m()\u001b[0m\n",
      "File \u001b[0;32m~/anaconda3/envs/MOLECULES/lib/python3.11/site-packages/pandas/_libs/index.pyx:176\u001b[0m, in \u001b[0;36mpandas._libs.index.IndexEngine.get_loc\u001b[0;34m()\u001b[0m\n",
      "File \u001b[0;32mpandas/_libs/hashtable_class_helper.pxi:7080\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[0;34m()\u001b[0m\n",
      "File \u001b[0;32mpandas/_libs/hashtable_class_helper.pxi:7088\u001b[0m, in \u001b[0;36mpandas._libs.hashtable.PyObjectHashTable.get_item\u001b[0;34m()\u001b[0m\n",
      "\u001b[0;31mKeyError\u001b[0m: 'SMILES'",
      "\nThe above exception was the direct cause of the following exception:\n",
      "\u001b[0;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "Cell \u001b[0;32mIn[3], line 12\u001b[0m\n\u001b[1;32m     10\u001b[0m \u001b[39m# Iterate over each row in dataframe\u001b[39;00m\n\u001b[1;32m     11\u001b[0m \u001b[39mfor\u001b[39;00m index, row \u001b[39min\u001b[39;00m data\u001b[39m.\u001b[39miterrows():\n\u001b[0;32m---> 12\u001b[0m     smiles \u001b[39m=\u001b[39m row[\u001b[39m'\u001b[39;49m\u001b[39mSMILES\u001b[39;49m\u001b[39m'\u001b[39;49m]\n\u001b[1;32m     13\u001b[0m     prop_list \u001b[39m=\u001b[39m [prop\u001b[39m.\u001b[39mstrip() \u001b[39mfor\u001b[39;00m prop \u001b[39min\u001b[39;00m \u001b[39mstr\u001b[39m(row[\u001b[39m'\u001b[39m\u001b[39mODOR\u001b[39m\u001b[39m'\u001b[39m])\u001b[39m.\u001b[39msplit(\u001b[39m'\u001b[39m\u001b[39m,\u001b[39m\u001b[39m'\u001b[39m)]\n\u001b[1;32m     15\u001b[0m     \u001b[39m# Check if SMILES notation is already present in odor dictionary,\u001b[39;00m\n\u001b[1;32m     16\u001b[0m     \u001b[39m# If not, add it as a new key with initial value of empty set {}\u001b[39;00m\n",
      "File \u001b[0;32m~/anaconda3/envs/MOLECULES/lib/python3.11/site-packages/pandas/core/series.py:1007\u001b[0m, in \u001b[0;36mSeries.__getitem__\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   1004\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_values[key]\n\u001b[1;32m   1006\u001b[0m \u001b[39melif\u001b[39;00m key_is_scalar:\n\u001b[0;32m-> 1007\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49m_get_value(key)\n\u001b[1;32m   1009\u001b[0m \u001b[39mif\u001b[39;00m is_hashable(key):\n\u001b[1;32m   1010\u001b[0m     \u001b[39m# Otherwise index.get_value will raise InvalidIndexError\u001b[39;00m\n\u001b[1;32m   1011\u001b[0m     \u001b[39mtry\u001b[39;00m:\n\u001b[1;32m   1012\u001b[0m         \u001b[39m# For labels that don't resolve as scalars like tuples and frozensets\u001b[39;00m\n",
      "File \u001b[0;32m~/anaconda3/envs/MOLECULES/lib/python3.11/site-packages/pandas/core/series.py:1116\u001b[0m, in \u001b[0;36mSeries._get_value\u001b[0;34m(self, label, takeable)\u001b[0m\n\u001b[1;32m   1113\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_values[label]\n\u001b[1;32m   1115\u001b[0m \u001b[39m# Similar to Index.get_value, but we do not fall back to positional\u001b[39;00m\n\u001b[0;32m-> 1116\u001b[0m loc \u001b[39m=\u001b[39m \u001b[39mself\u001b[39;49m\u001b[39m.\u001b[39;49mindex\u001b[39m.\u001b[39;49mget_loc(label)\n\u001b[1;32m   1118\u001b[0m \u001b[39mif\u001b[39;00m is_integer(loc):\n\u001b[1;32m   1119\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_values[loc]\n",
      "File \u001b[0;32m~/anaconda3/envs/MOLECULES/lib/python3.11/site-packages/pandas/core/indexes/base.py:3655\u001b[0m, in \u001b[0;36mIndex.get_loc\u001b[0;34m(self, key)\u001b[0m\n\u001b[1;32m   3653\u001b[0m     \u001b[39mreturn\u001b[39;00m \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_engine\u001b[39m.\u001b[39mget_loc(casted_key)\n\u001b[1;32m   3654\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mKeyError\u001b[39;00m \u001b[39mas\u001b[39;00m err:\n\u001b[0;32m-> 3655\u001b[0m     \u001b[39mraise\u001b[39;00m \u001b[39mKeyError\u001b[39;00m(key) \u001b[39mfrom\u001b[39;00m \u001b[39merr\u001b[39;00m\n\u001b[1;32m   3656\u001b[0m \u001b[39mexcept\u001b[39;00m \u001b[39mTypeError\u001b[39;00m:\n\u001b[1;32m   3657\u001b[0m     \u001b[39m# If we have a listlike key, _check_indexing_error will raise\u001b[39;00m\n\u001b[1;32m   3658\u001b[0m     \u001b[39m#  InvalidIndexError. Otherwise we fall through and re-raise\u001b[39;00m\n\u001b[1;32m   3659\u001b[0m     \u001b[39m#  the TypeError.\u001b[39;00m\n\u001b[1;32m   3660\u001b[0m     \u001b[39mself\u001b[39m\u001b[39m.\u001b[39m_check_indexing_error(key)\n",
      "\u001b[0;31mKeyError\u001b[0m: 'SMILES'"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import itertools\n",
    "\n",
    "# Read the CSV file\n",
    "data = pd.read_csv('/home/ritesh/Desktop/MOLECULES/morgan/data.csv')\n",
    "\n",
    "# Create an empty dictionary to store unique properties and their corresponding SMILES notations\n",
    "odor = {}\n",
    "\n",
    "# Iterate over each row in dataframe\n",
    "for index, row in data.iterrows():\n",
    "    smiles = row['SMILES']\n",
    "    prop_list = [prop.strip() for prop in str(row['ODOR']).split(',')]\n",
    "\n",
    "    # Check if SMILES notation is already present in odor dictionary,\n",
    "    # If not, add it as a new key with initial value of empty set {}\n",
    "    if smiles not in odor:\n",
    "        odor[smiles] = set()\n",
    "\n",
    "    # Add each property to corresponding SMILES notation set\n",
    "    for prop in prop_list:\n",
    "        if prop != '':\n",
    "            odor[smiles].add(prop)\n",
    "\n",
    "# Get all unique property values\n",
    "all_properties = sorted(set(prop for props in odor.values() for prop in props))\n",
    "\n",
    "# Create an empty DataFrame with columns as unique property values and rows as unique SMILES notations\n",
    "property_df = pd.DataFrame(0,index=odor.keys(),columns=all_properties)\n",
    "\n",
    "# Set 1 or 0 based on presence or absence of each property for respective SMILES notation\n",
    "for smiles, props_set in odor.items():\n",
    "     property_df.loc[smiles,list(props_set)] += 1\n",
    "\n",
    "print(property_df)\n",
    "\n",
    "def generate_edge(x, colName):\n",
    "    temp = list(colName[(x > 0).values])\n",
    "\n",
    "    if len(temp) > 1:\n",
    "        edges = list(itertools.permutations(temp, r=2))\n",
    "    else:\n",
    "        edges = []\n",
    "\n",
    "    return edges\n",
    "\n",
    "colName = property_df.columns\n",
    "non_zero_cols = property_df.apply(lambda x: generate_edge(x, colName), axis=1)\n",
    "print(non_zero_cols)\n",
    "\n",
    "relations_list = []\n",
    "for index, val in non_zero_cols.items():\n",
    "    relations_list.extend(val)\n",
    "\n",
    "print(len(relations_list))\n",
    "\n",
    "# Create a DataFrame containing all unique odor properties\n",
    "df_aroma = pd.DataFrame(all_properties, columns=['Odor Properties'])\n",
    "\n",
    "# Print the occurrence of each odor property in the DataFrame\n",
    "odor_occurrence = property_df.sum().reset_index()\n",
    "odor_occurrence.columns = ['Odor Property', 'Occurrence']\n",
    "print(odor_occurrence)\n",
    "\n",
    "# Add the code to create df_aroma and print odor occurrence to your original code"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from rdkit import Chem, DataStructs\n",
    "from rdkit.Chem import Descriptors, rdMolDescriptors\n",
    "import pandas as pd\n",
    "\n",
    "# Read the CSV file containing SMILES from original input\n",
    "filepath1 = '/home/ritesh/Desktop/MOLECULES/morgan/finaldatasetman.csv'\n",
    "data = pd.read_csv(filepath1)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['MaxEStateIndex', 'MinEStateIndex', 'MaxAbsEStateIndex', 'MinAbsEStateIndex', 'qed', 'MolWt', 'HeavyAtomMolWt', 'ExactMolWt', 'NumValenceElectrons', 'NumRadicalElectrons', 'MaxPartialCharge', 'MinPartialCharge', 'MaxAbsPartialCharge', 'MinAbsPartialCharge', 'FpDensityMorgan1', 'FpDensityMorgan2', 'FpDensityMorgan3', 'BCUT2D_MWHI', 'BCUT2D_MWLOW', 'BCUT2D_CHGHI', 'BCUT2D_CHGLO', 'BCUT2D_LOGPHI', 'BCUT2D_LOGPLOW', 'BCUT2D_MRHI', 'BCUT2D_MRLOW', 'BalabanJ', 'BertzCT', 'Chi0', 'Chi0n', 'Chi0v', 'Chi1', 'Chi1n', 'Chi1v', 'Chi2n', 'Chi2v', 'Chi3n', 'Chi3v', 'Chi4n', 'Chi4v', 'HallKierAlpha', 'Ipc', 'Kappa1', 'Kappa2', 'Kappa3', 'LabuteASA', 'PEOE_VSA1', 'PEOE_VSA10', 'PEOE_VSA11', 'PEOE_VSA12', 'PEOE_VSA13', 'PEOE_VSA14', 'PEOE_VSA2', 'PEOE_VSA3', 'PEOE_VSA4', 'PEOE_VSA5', 'PEOE_VSA6', 'PEOE_VSA7', 'PEOE_VSA8', 'PEOE_VSA9', 'SMR_VSA1', 'SMR_VSA10', 'SMR_VSA2', 'SMR_VSA3', 'SMR_VSA4', 'SMR_VSA5', 'SMR_VSA6', 'SMR_VSA7', 'SMR_VSA8', 'SMR_VSA9', 'SlogP_VSA1', 'SlogP_VSA10', 'SlogP_VSA11', 'SlogP_VSA12', 'SlogP_VSA2', 'SlogP_VSA3', 'SlogP_VSA4', 'SlogP_VSA5', 'SlogP_VSA6', 'SlogP_VSA7', 'SlogP_VSA8', 'SlogP_VSA9', 'TPSA', 'EState_VSA1', 'EState_VSA10', 'EState_VSA11', 'EState_VSA2', 'EState_VSA3', 'EState_VSA4', 'EState_VSA5', 'EState_VSA6', 'EState_VSA7', 'EState_VSA8', 'EState_VSA9', 'VSA_EState1', 'VSA_EState10', 'VSA_EState2', 'VSA_EState3', 'VSA_EState4', 'VSA_EState5', 'VSA_EState6', 'VSA_EState7', 'VSA_EState8', 'VSA_EState9', 'FractionCSP3', 'HeavyAtomCount', 'NHOHCount', 'NOCount', 'NumAliphaticCarbocycles', 'NumAliphaticHeterocycles', 'NumAliphaticRings', 'NumAromaticCarbocycles', 'NumAromaticHeterocycles', 'NumAromaticRings', 'NumHAcceptors', 'NumHDonors', 'NumHeteroatoms', 'NumRotatableBonds', 'NumSaturatedCarbocycles', 'NumSaturatedHeterocycles', 'NumSaturatedRings', 'RingCount', 'MolLogP', 'MolMR', 'fr_Al_COO', 'fr_Al_OH', 'fr_Al_OH_noTert', 'fr_ArN', 'fr_Ar_COO', 'fr_Ar_N', 'fr_Ar_NH', 'fr_Ar_OH', 'fr_COO', 'fr_COO2', 'fr_C_O', 'fr_C_O_noCOO', 'fr_C_S', 'fr_HOCCN', 'fr_Imine', 'fr_NH0', 'fr_NH1', 'fr_NH2', 'fr_N_O', 'fr_Ndealkylation1', 'fr_Ndealkylation2', 'fr_Nhpyrrole', 'fr_SH', 'fr_aldehyde', 'fr_alkyl_carbamate', 'fr_alkyl_halide', 'fr_allylic_oxid', 'fr_amide', 'fr_amidine', 'fr_aniline', 'fr_aryl_methyl', 'fr_azide', 'fr_azo', 'fr_barbitur', 'fr_benzene', 'fr_benzodiazepine', 'fr_bicyclic', 'fr_diazo', 'fr_dihydropyridine', 'fr_epoxide', 'fr_ester', 'fr_ether', 'fr_furan', 'fr_guanido', 'fr_halogen', 'fr_hdrzine', 'fr_hdrzone', 'fr_imidazole', 'fr_imide', 'fr_isocyan', 'fr_isothiocyan', 'fr_ketone', 'fr_ketone_Topliss', 'fr_lactam', 'fr_lactone', 'fr_methoxy', 'fr_morpholine', 'fr_nitrile', 'fr_nitro', 'fr_nitro_arom', 'fr_nitro_arom_nonortho', 'fr_nitroso', 'fr_oxazole', 'fr_oxime', 'fr_para_hydroxylation', 'fr_phenol', 'fr_phenol_noOrthoHbond', 'fr_phos_acid', 'fr_phos_ester', 'fr_piperdine', 'fr_piperzine', 'fr_priamide', 'fr_prisulfonamd', 'fr_pyridine', 'fr_quatN', 'fr_sulfide', 'fr_sulfonamd', 'fr_sulfone', 'fr_term_acetylene', 'fr_tetrazole', 'fr_thiazole', 'fr_thiocyan', 'fr_thiophene', 'fr_unbrch_alkane', 'fr_urea']\n"
     ]
    }
   ],
   "source": [
    "from rdkit import Chem    # make sure to import it if you haven't done so\n",
    "from rdkit.Chem import Descriptors    # make sure to import it if you haven't done so\n",
    "descriptors_list = [x[0] for x in Descriptors._descList]\n",
    "print(descriptors_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from rdkit import Chem\n",
    "from rdkit.Chem import Descriptors\n",
    "\n",
    "# Read input CSV file containing SMILES strings\n",
    "filepath1 = '/home/ritesh/Desktop/MOLECULES/morgan/finaldatasetman.csv'\n",
    "data = pd.read_csv(filepath1)\n",
    "\n",
    "# Calculate descriptors for each SMILES string\n",
    "# Calculate descriptors for each SMILES string\n",
    "descriptors = []\n",
    "for smiles in data[\"SMILES\"]:\n",
    "    mol = Chem.MolFromSmiles(smiles)\n",
    "    descriptor_values = [\n",
    "        Descriptors.MaxEStateIndex(mol),\n",
    "        Descriptors.MinEStateIndex(mol),\n",
    "        Descriptors.MaxAbsEStateIndex(mol),\n",
    "        Descriptors.MinAbsEStateIndex(mol),\n",
    "        Descriptors.qed(mol),\n",
    "        Descriptors.MolWt(mol),\n",
    "        Descriptors.HeavyAtomMolWt(mol),\n",
    "        Descriptors.ExactMolWt(mol),\n",
    "        Descriptors.NumValenceElectrons(mol),\n",
    "        Descriptors.NumRadicalElectrons(mol),\n",
    "        Descriptors.MaxPartialCharge(mol),\n",
    "        Descriptors.MinPartialCharge(mol),\n",
    "        Descriptors.MaxAbsPartialCharge(mol),\n",
    "        Descriptors.MinAbsPartialCharge(mol),\n",
    "        Descriptors.FpDensityMorgan1(mol),\n",
    "        Descriptors.FpDensityMorgan2(mol),\n",
    "        Descriptors.FpDensityMorgan3(mol),\n",
    "        Descriptors.BalabanJ(mol),\n",
    "        Descriptors.BertzCT(mol),\n",
    "        Descriptors.Chi0(mol),\n",
    "        Descriptors.Chi0n(mol),\n",
    "        Descriptors.Chi0v(mol),\n",
    "        Descriptors.Chi1(mol),\n",
    "        Descriptors.Chi1n(mol),\n",
    "        Descriptors.Chi1v(mol),\n",
    "        Descriptors.Chi2n(mol),\n",
    "        Descriptors.Chi2v(mol),\n",
    "        Descriptors.Chi3n(mol),\n",
    "        Descriptors.Chi3v(mol),\n",
    "        Descriptors.Chi4n(mol),\n",
    "        Descriptors.Chi4v(mol),\n",
    "        Descriptors.HallKierAlpha(mol),\n",
    "        Descriptors.Ipc(mol),\n",
    "        Descriptors.Kappa1(mol),\n",
    "        Descriptors.Kappa2(mol),\n",
    "        Descriptors.Kappa3(mol),\n",
    "        Descriptors.LabuteASA(mol),\n",
    "        Descriptors.PEOE_VSA1(mol),\n",
    "        Descriptors.PEOE_VSA10(mol),\n",
    "        Descriptors.PEOE_VSA11(mol),\n",
    "        Descriptors.PEOE_VSA12(mol),\n",
    "        Descriptors.PEOE_VSA13(mol),\n",
    "        Descriptors.PEOE_VSA14(mol),\n",
    "        Descriptors.PEOE_VSA2(mol),\n",
    "        Descriptors.PEOE_VSA3(mol),\n",
    "        Descriptors.PEOE_VSA4(mol),\n",
    "        Descriptors.PEOE_VSA5(mol),\n",
    "        Descriptors.PEOE_VSA6(mol),\n",
    "        Descriptors.PEOE_VSA7(mol),\n",
    "        Descriptors.PEOE_VSA8(mol),\n",
    "        Descriptors.PEOE_VSA9(mol),\n",
    "        Descriptors.SMR_VSA1(mol),\n",
    "        Descriptors.SMR_VSA10(mol),\n",
    "        Descriptors.SMR_VSA2(mol),\n",
    "        Descriptors.SMR_VSA3(mol),\n",
    "        Descriptors.SMR_VSA4(mol),\n",
    "        Descriptors.SMR_VSA5(mol),\n",
    "        Descriptors.SMR_VSA6(mol),\n",
    "        Descriptors.SMR_VSA7(mol),\n",
    "        Descriptors.SMR_VSA8(mol),\n",
    "        Descriptors.SMR_VSA9(mol),\n",
    "        Descriptors.SlogP_VSA1(mol),\n",
    "        Descriptors.SlogP_VSA10(mol),\n",
    "        Descriptors.SlogP_VSA11(mol),\n",
    "        Descriptors.SlogP_VSA12(mol),\n",
    "        Descriptors.SlogP_VSA2(mol),\n",
    "        Descriptors.SlogP_VSA3(mol),\n",
    "        Descriptors.SlogP_VSA4(mol),\n",
    "        Descriptors.SlogP_VSA5(mol),\n",
    "        Descriptors.SlogP_VSA6(mol),\n",
    "        Descriptors.SlogP_VSA7(mol),\n",
    "        Descriptors.SlogP_VSA8(mol),\n",
    "        Descriptors.SlogP_VSA9(mol),\n",
    "        Descriptors.TPSA(mol),\n",
    "        Descriptors.EState_VSA1(mol),\n",
    "        Descriptors.EState_VSA10(mol),\n",
    "        Descriptors.EState_VSA11(mol),\n",
    "        Descriptors.EState_VSA2(mol),\n",
    "        Descriptors.EState_VSA3(mol),\n",
    "        Descriptors.EState_VSA4(mol),\n",
    "        Descriptors.EState_VSA5(mol),\n",
    "        Descriptors.EState_VSA6(mol),\n",
    "        Descriptors.EState_VSA7(mol),\n",
    "        Descriptors.EState_VSA8(mol),\n",
    "        Descriptors.EState_VSA9(mol),\n",
    "        Descriptors.VSA_EState1(mol),\n",
    "        Descriptors.VSA_EState10(mol),\n",
    "        Descriptors.VSA_EState2(mol),\n",
    "        Descriptors.VSA_EState3(mol),\n",
    "        Descriptors.VSA_EState4(mol),\n",
    "        Descriptors.VSA_EState5(mol),\n",
    "        Descriptors.VSA_EState6(mol),\n",
    "        Descriptors.VSA_EState7(mol),\n",
    "        Descriptors.VSA_EState8(mol),\n",
    "        Descriptors.VSA_EState9(mol),\n",
    "        Descriptors.FractionCSP3(mol),\n",
    "        Descriptors.HeavyAtomCount(mol),\n",
    "        Descriptors.NHOHCount(mol),\n",
    "        Descriptors.NOCount(mol),\n",
    "        Descriptors.NumAliphaticCarbocycles(mol),\n",
    "        Descriptors.NumAliphaticHeterocycles(mol),\n",
    "        Descriptors.NumAliphaticRings(mol),\n",
    "        Descriptors.NumAromaticCarbocycles(mol),\n",
    "        Descriptors.NumAromaticHeterocycles(mol),\n",
    "        Descriptors.NumAromaticRings(mol),\n",
    "        Descriptors.NumHAcceptors(mol),\n",
    "        Descriptors.NumHDonors(mol),\n",
    "        Descriptors.NumHeteroatoms(mol),\n",
    "        Descriptors.NumRotatableBonds(mol),\n",
    "        Descriptors.NumSaturatedCarbocycles(mol),\n",
    "        Descriptors.NumSaturatedHeterocycles(mol),\n",
    "        Descriptors.NumSaturatedRings(mol),\n",
    "        Descriptors.RingCount(mol),\n",
    "        Descriptors.MolLogP(mol),\n",
    "        Descriptors.MolMR(mol)\n",
    "    ]\n",
    "    descriptors.append(descriptor_values)\n",
    "\n",
    "\n",
    "# Create a DataFrame to store the calculated descriptors and SMILES strings\n",
    "descriptor_names = [\n",
    "    \"MaxEStateIndex\", \"MinEStateIndex\", \"MaxAbsEStateIndex\", \"MinAbsEStateIndex\",\n",
    "    \"qed\", \"MolecularWeight\", \"HeavyAtomMolecularWeight\", \"ExactMolecularWeight\",\n",
    "    \"NumValenceElectrons\", \"NumRadicalElectrons\", \"MaxPartialCharge\", \"MinPartialCharge\",\n",
    "    \"MaxAbsPartialCharge\", \"MinAbsPartialCharge\", \"FpDensityMorgan1\", \"FpDensityMorgan2\",\n",
    "    \"FpDensityMorgan3\", \"BalabanJ\", \"BertzCT\", \"Chi0\", \"Chi0n\", \"Chi0v\", \"Chi1\", \"Chi1n\",\n",
    "    \"Chi1v\", \"Chi2n\", \"Chi2v\", \"Chi3n\", \"Chi3v\", \"Chi4n\", \"Chi4v\", \"HallKierAlpha\", \"Ipc\",\n",
    "    \"Kappa1\", \"Kappa2\", \"Kappa3\", \"LabuteASA\", \"PEOE_VSA1\", \"PEOE_VSA10\", \"PEOE_VSA11\",\n",
    "    \"PEOE_VSA12\", \"PEOE_VSA13\", \"PEOE_VSA14\", \"PEOE_VSA2\", \"PEOE_VSA3\", \"PEOE_VSA4\",\n",
    "    \"PEOE_VSA5\", \"PEOE_VSA6\", \"PEOE_VSA7\", \"PEOE_VSA8\", \"PEOE_VSA9\", \"SMR_VSA1\", \"SMR_VSA10\",\n",
    "    \"SMR_VSA2\", \"SMR_VSA3\", \"SMR_VSA4\", \"SMR_VSA5\", \"SMR_VSA6\", \"SMR_VSA7\", \"SMR_VSA8\",\n",
    "    \"SMR_VSA9\", \"SlogP_VSA1\", \"SlogP_VSA10\", \"SlogP_VSA11\", \"SlogP_VSA12\", \"SlogP_VSA2\",\n",
    "    \"SlogP_VSA3\", \"SlogP_VSA4\", \"SlogP_VSA5\", \"SlogP_VSA6\", \"SlogP_VSA7\", \"SlogP_VSA8\",\n",
    "    \"SlogP_VSA9\", \"TPSA\", \"EState_VSA1\", \"EState_VSA10\", \"EState_VSA11\", \"EState_VSA2\",\n",
    "    \"EState_VSA3\", \"EState_VSA4\", \"EState_VSA5\", \"EState_VSA6\", \"EState_VSA7\", \"EState_VSA8\",\n",
    "    \"EState_VSA9\", \"VSA_EState1\", \"VSA_EState10\", \"VSA_EState2\", \"VSA_EState3\", \"VSA_EState4\",\n",
    "    \"VSA_EState5\", \"VSA_EState6\", \"VSA_EState7\", \"VSA_EState8\", \"VSA_EState9\", \"FractionCSP3\",\n",
    "    \"HeavyAtomCount\", \"NHOHCount\", \"NOCount\", \"NumAliphaticCarbocycles\",\n",
    "    \"NumAliphaticHeterocycles\", \"NumAliphaticRings\", \"NumAromaticCarbocycles\",\n",
    "    \"NumAromaticHeterocycles\", \"NumAromaticRings\", \"NumHAcceptors\", \"NumHDonors\",\n",
    "    \"NumHeteroatoms\", \"NumRotatableBonds\", \"NumSaturatedCarbocycles\",\n",
    "    \"NumSaturatedHeterocycles\", \"NumSaturatedRings\", \"RingCount\", \"MolLogP\", \"MolMR\"\n",
    "]\n",
    "descriptor_df = pd.DataFrame(descriptors, columns=descriptor_names)\n",
    "result_df = pd.concat([data[\"SMILES\"], descriptor_df], axis=1)\n",
    "\n",
    "# Save the results to a new CSV file\n",
    "output_file = \"testddf.csv\"\n",
    "result_df.to_csv(output_file, index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from rdkit import Chem\n",
    "from rdkit.Chem import Descriptors\n",
    "\n",
    "# Read input CSV file containing SMILES strings\n",
    "filepath1 = '/home/ritesh/Desktop/MOLECULES/morgan/finaldatasetman.csv'\n",
    "data = pd.read_csv(filepath1)\n",
    "\n",
    "# Calculate descriptors for each SMILES string\n",
    "descriptors = []\n",
    "for smiles in data[\"SMILES\"]:\n",
    "    mol = Chem.MolFromSmiles(smiles)\n",
    "    descriptor_values = [getattr(Descriptors, desc[0])(mol) for desc in Descriptors.descList]\n",
    "    descriptors.append(descriptor_values)\n",
    "\n",
    "# Create a DataFrame to store the calculated descriptors and SMILES strings\n",
    "descriptor_names = [desc[0] for desc in Descriptors.descList]\n",
    "descriptor_df = pd.DataFrame(descriptors, columns=descriptor_names)\n",
    "result_df = pd.concat([data[\"SMILES\"], descriptor_df], axis=1)\n",
    "\n",
    "# Save the results to a new CSV file\n",
    "output_file = \"1dtestttsts.csv\"\n",
    "result_df.to_csv(output_file, index=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "from rdkit import Chem\n",
    "from rdkit.Chem import Descriptors3D\n",
    "from rdkit.Chem import AllChem\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from rdkit import Chem\n",
    "from rdkit.Chem import Descriptors3D\n",
    "from rdkit.Chem import AllChem\n",
    "\n",
    "# Read input CSV file containing SMILES strings\n",
    "input_file = '/home/ritesh/Desktop/MOLECULES/morgan/finaldatasetman.csv'\n",
    "df = pd.read_csv(input_file)\n",
    "\n",
    "# Initialize lists to store the descriptors\n",
    "descriptors = {\n",
    "    'RadiusOfGyration': [],\n",
    "    'InertialShapeFactor': [],\n",
    "    'Eccentricity': [],\n",
    "    'Asphericity': [],\n",
    "    'SpherocityIndex': [],\n",
    "    'PrincipalMomentsOfInertia1': [],\n",
    "    'PrincipalMomentsOfInertia2': [],\n",
    "    'PrincipalMomentsOfInertia3': [],\n",
    "    'NormalizedPrincipalMomentsRatio1': [],\n",
    "    'NormalizedPrincipalMomentsRatio2': []\n",
    "}\n",
    "\n",
    "# For each molecule in the DataFrame\n",
    "for index, row in df.iterrows():\n",
    "    smiles = row['SMILES']  # Getting the SMILES string from the \"SMILES\" column for the current row\n",
    "\n",
    "    # Create a molecule from the SMILES string\n",
    "    molecule = Chem.MolFromSmiles(smiles)\n",
    "\n",
    "    # Add hydrogens to the molecule\n",
    "    molecule = Chem.AddHs(molecule)\n",
    "\n",
    "    # Generate a 3D conformation using the ETKDG method\n",
    "    AllChem.EmbedMolecule(molecule, AllChem.ETKDG())\n",
    "\n",
    "    # Compute the descriptors\n",
    "    descriptors['RadiusOfGyration'].append(Descriptors3D.RadiusOfGyration(molecule))\n",
    "    descriptors['InertialShapeFactor'].append(Descriptors3D.InertialShapeFactor(molecule))\n",
    "    descriptors['Eccentricity'].append(Descriptors3D.Eccentricity(molecule))\n",
    "    descriptors['Asphericity'].append(Descriptors3D.Asphericity(molecule))\n",
    "    descriptors['SpherocityIndex'].append(Descriptors3D.SpherocityIndex(molecule))\n",
    "    descriptors['PrincipalMomentsOfInertia1'].append(Descriptors3D.PMI1(molecule))\n",
    "    descriptors['PrincipalMomentsOfInertia2'].append(Descriptors3D.PMI2(molecule))\n",
    "    descriptors['PrincipalMomentsOfInertia3'].append(Descriptors3D.PMI3(molecule))\n",
    "    descriptors['NormalizedPrincipalMomentsRatio1'].append(Descriptors3D.NPR1(molecule))\n",
    "    descriptors['NormalizedPrincipalMomentsRatio2'].append(Descriptors3D.NPR2(molecule))\n",
    "\n",
    "# Create a DataFrame to store the descriptors\n",
    "descriptor_df = pd.DataFrame(descriptors)\n",
    "\n",
    "# Concatenate the SMILES column and descriptor DataFrame\n",
    "output_df = pd.concat([df['SMILES'], descriptor_df], axis=1)\n",
    "\n",
    "# Save the updated DataFrame to a CSV file\n",
    "output_file = '3D_DESC.csv'\n",
    "output_df.to_csv(output_file, index=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Explained Variance Ratio for PC1: 0.23376332656076104\n",
      "Explained Variance Ratio for PC2: 0.11856045974014193\n",
      "Explained Variance Ratio for PC3: 0.11013660991419158\n",
      "Explained Variance Ratio for PC4: 0.07342453795240272\n",
      "Explained Variance Ratio for PC5: 0.06143806031226038\n",
      "Explained Variance Ratio for PC6: 0.04811668207159402\n",
      "Explained Variance Ratio for PC7: 0.044977280239093045\n",
      "Explained Variance Ratio for PC8: 0.03444064276758061\n",
      "Explained Variance Ratio for PC9: 0.03000761934308288\n",
      "Explained Variance Ratio for PC10: 0.027768338350963005\n",
      "Explained Variance Ratio for PC11: 0.02460018139122922\n",
      "Explained Variance Ratio for PC12: 0.020821454536008338\n",
      "Explained Variance Ratio for PC13: 0.01977810533302289\n",
      "Explained Variance Ratio for PC14: 0.01859820118368153\n",
      "Explained Variance Ratio for PC15: 0.016267425100278454\n",
      "Explained Variance Ratio for PC16: 0.01363826878688359\n",
      "Explained Variance Ratio for PC17: 0.012404470152131062\n",
      "Explained Variance Ratio for PC18: 0.010673080629703624\n",
      "Explained Variance Ratio for PC19: 0.010331609638330566\n",
      "Explained Variance Ratio for PC20: 0.008774576308775293\n",
      "Explained Variance Ratio for PC21: 0.007506603658049943\n",
      "Explained Variance Ratio for PC22: 0.007225022476517391\n",
      "Explained Variance Ratio for PC23: 0.005823419502944831\n",
      "Explained Variance Ratio for PC24: 0.005385558599812207\n",
      "Explained Variance Ratio for PC25: 0.004490556999791083\n",
      "Explained Variance Ratio for PC26: 0.004303525229692677\n",
      "Explained Variance Ratio for PC27: 0.003546443857455578\n",
      "Explained Variance Ratio for PC28: 0.003211157012985616\n",
      "Explained Variance Ratio for PC29: 0.002687768624845577\n",
      "Explained Variance Ratio for PC30: 0.002614946829848211\n",
      "Explained Variance Ratio for PC31: 0.002204242356914825\n",
      "Explained Variance Ratio for PC32: 0.0019112497019058315\n",
      "Explained Variance Ratio for PC33: 0.0016268760486279389\n",
      "Explained Variance Ratio for PC34: 0.0014016563388021465\n",
      "Explained Variance Ratio for PC35: 0.0011861147403988163\n",
      "Explained Variance Ratio for PC36: 0.0011042837969173895\n",
      "Explained Variance Ratio for PC37: 0.0009806936634721127\n",
      "Explained Variance Ratio for PC38: 0.0007077934288714786\n",
      "Explained Variance Ratio for PC39: 0.00060341054594515\n",
      "Explained Variance Ratio for PC40: 0.0005420205997063216\n",
      "Explained Variance Ratio for PC41: 0.0004591488814740449\n",
      "Explained Variance Ratio for PC42: 0.00042203266152354566\n",
      "Explained Variance Ratio for PC43: 0.00033901736645550586\n",
      "Explained Variance Ratio for PC44: 0.0002966796966389069\n",
      "Explained Variance Ratio for PC45: 0.00022391700484918786\n",
      "Explained Variance Ratio for PC46: 0.00016948244870495588\n",
      "Explained Variance Ratio for PC47: 0.00012342661199971148\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "from sklearn.decomposition import PCA\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "\n",
    "# Read the CSV file into a DataFrame\n",
    "input_file = \"/home/ritesh/Desktop/MOLECULES/morgan/ALLDESCRIPTORS.csv\"\n",
    "df = pd.read_csv(input_file)\n",
    "\n",
    "# Separate SMILES column from descriptor columns\n",
    "smiles = df['SMILES']\n",
    "descriptors = df.drop('SMILES', axis=1)\n",
    "\n",
    "# Normalize the descriptor columns\n",
    "scaler = StandardScaler()\n",
    "descriptors_normalized = scaler.fit_transform(descriptors)\n",
    "\n",
    "# Perform PCA\n",
    "n_components = 47  # Specify the desired number of components\n",
    "pca = PCA(n_components=n_components)\n",
    "pca_results = pca.fit_transform(descriptors_normalized)\n",
    "\n",
    "# Explained variance ratio\n",
    "explained_variance_ratio = pca.explained_variance_ratio_\n",
    "\n",
    "# Print explained variance ratio\n",
    "for i, ratio in enumerate(explained_variance_ratio):\n",
    "    print(f\"Explained Variance Ratio for PC{i+1}: {ratio}\")\n",
    "\n",
    "# Create a new DataFrame with PCA results\n",
    "pca_columns = [f\"PC{i+1}\" for i in range(n_components)]\n",
    "pca_df = pd.DataFrame(data=pca_results, columns=pca_columns)\n",
    "\n",
    "# Add the SMILES column to the PCA DataFrame\n",
    "pca_df['SMILES'] = smiles\n",
    "\n",
    "# Save the PCA results to a CSV file\n",
    "output_file = \"pca_results.csv\"\n",
    "pca_df.to_csv(output_file, index=False)\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.3"
  },
  "orig_nbformat": 4
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
